// --- Global Variables ---
let cy; // Cytoscape instance
let currentConfig = null; // Represents the currently loaded/active config object { id, name, graph_structure }
let defaultGraphStructure = null; // To store the structure fetched from backend
let sessionLog = []; // Logs for the current browser session
let edgeHandlesInstance = null; // Reference to edge handles extension API
let contextMenuInstance = null; // Reference to context menus extension API
let newNodeCounter = 0; // Counter for generating unique default node IDs
// Flags to track successful registration
let didRegisterEdgehandles = false;
let didRegisterContextMenus = false;


// ===========================================
// --- ALL HELPER FUNCTION DEFINITIONS ---
// ===========================================
// Define functions BEFORE they are called by DOMContentLoaded or other functions

function nodeLabelFunc(node) {
    const id = node.data('id');
    const fullName = node.data('fullName') || id;
    const currentLabel = node.data = node.data('currentProbLabel'); // Set by updateNodeProbabilities
    return `${id}: ${fullName}\n${currentLabel || '(N/A)'}`;
}

function simulateIsDag(graph) {
    if (!graph || !graph.nodes || !graph.edges) { console.warn("simulateIsDag: Invalid graph structure."); return false; }
    const adj = {}; const nodesSet = new Set();
    graph('currentProbLabel'); // Set by updateNodeProbabilities
    return `${id}: ${fullName}\n${currentLabel || '(N/A)'}`;
}

// Client-side cycle check helper (DFS based)
function simulateIsDag(graph) {
    if (!graph || !graph.nodes || !graph.edges) { console.warn("simulateIsDag: Invalid graph structure."); return false; }
    const adj = {}; const nodesSet = new Set();
    graph.nodes.forEach(n => { if (n && n.id) { adj[n.id] = []; nodesSet.add(n.id); } else { console.warn("simulateIsDag: Skipping invalid node object during init:", n); } });
    graph.edges.forEach(e => { if (e && e.); } });
    graph.edges.forEach(e => { if (e && e.source && e.source && e.target && nodesSet.has(e.source) && nodesSet.has(e.targettarget && nodesSet.has(e.source) && nodesSet.has(e.target)) { if ()) { if (e.source in adj) { adj[e.source].push(e.target); }e.source in adj) { adj[e.source].push(e.target); } else { adj[ else { adj[e.source] = [e.target]; console.warn(`simulateIsDag: Source ${e.source] = [e.target]; console.warn(`simulateIsDag: Source ${e.source}e.source} init`); } } else { console.warn(`simulateIsDag: Invalid edge:`, e); } init`); } } else { console.warn(`simulateIsDag: Invalid edge:`, e); } });
    const });
    const path = new Set(); const visited = new Set();
    function dfs(node) { path path = new Set(); const visited = new Set();
    function dfs(node) { path.add(node.add(node); visited.add(node); for (const neighbor of adj[node] || []) { if); visited.add(node); for (const neighbor of adj[node] || []) { if (!nodesSet. (!nodesSet.has(neighbor)) continue; if (path.has(neighbor)) { console.log(`Cyclehas(neighbor)) continue; if (path.has(neighbor)) { console.log(`Cycle detected: ${neighbor} in ${: ${neighbor} in ${Array.from(path).join('->')}`); return false; } if (!visitedArray.from(path).join('->')}`); return false; } if (!visited.has(neighbor)) {.has(neighbor)) { if (!dfs(neighbor)) return false; } } path.delete(node); return if (!dfs(neighbor)) return false; } } path.delete(node); return true; }
    for true; }
    for (const node of nodesSet) { if (!visited.has(node)) { if (const node of nodesSet) { if (!visited.has(node)) { if (!dfs(node)) return (!dfs(node)) return false; } }
    return true;
}

// --- Utility Functions ---
function select false; } }
    return true;
}

function selectConfigInDropdown(configId) { const select = document.ConfigInDropdown(configId) { const select = document.getElementById('load-config-select'); if (select) selectgetElementById('load-config-select'); if (select) select.value = configId; }
function enableUI(.value = configId; }
function enableUI(enable) { const buttons = document.querySelectorAll('button');enable) { const buttons = document.querySelectorAll('button'); const inputs = document.querySelectorAll('input, select'); buttons const inputs = document.querySelectorAll('input, select'); buttons.forEach(btn => btn.disabled = !enable);.forEach(btn => btn.disabled = !enable); inputs.forEach(inp => inp.disabled = !enable inputs.forEach(inp => inp.disabled = !enable); const toggle = document.getElementById('gradient-toggle'); if(toggle); const toggle = document.getElementById('gradient-toggle'); if(toggle) toggle.disabled = false; document.body.style) toggle.disabled = false; document.body.style.cursor = enable ? 'default' : 'wait';.cursor = enable ? 'default' : 'wait'; }
function showSpinner(show) { const spinner = document.getElementById }
function showSpinner(show) { const spinner = document.getElementById('loading-spinner'); if (spinner) spinner.classList('loading-spinner'); if (spinner) spinner.classList.toggle('hidden', !show); }
function run.toggle('hidden', !show); }
function runLayout() { if (!cy) return; let l = 'colaLayout() { if (!cy) return; let l = 'cola'; try { cy.layout({ name: ''; try { cy.layout({ name: 'cola', animate:true, nodeSpacing: 50, edgecola', animate:true, nodeSpacing: 50, edgeLength: 180, padding: 30Length: 180, padding: 30 }).run(); } catch (e) { console.warn }).run(); } catch (e) { console.warn('Cola failed, using dagre'); l = 'dagre'; try { cy.layout({ name: 'dagre', rankDir:'TB', spacingFactor: 1('Cola failed, using dagre'); l = 'dagre'; try { cy.layout({ name: 'dag.2 }).run(); } catch (e) { console.error('Layouts failed'); l = 'grid';re', rankDir:'TB', spacingFactor: 1.2 }).run(); } catch (e) { console.error('Layouts failed'); l = 'grid'; try { cy.layout({ name: 'grid' }). try { cy.layout({ name: 'grid' }).run(); } catch(e) { console.error("run(); } catch(e) { console.error("Grid layout failed too!")}}} console.log('Using layout:', lGrid layout failed too!")}}} console.log('Using layout:', l); }
function updateInputControls(nodes) { const); }
function updateInputControls(nodes) { const c = document.getElementById('input-controls-container'); c = document.getElementById('input-controls-container'); if (!c) return; c.innerHTML = ''; const i if (!c) return; c.innerHTML = ''; const iN = nodes.filter(n => n.nodeType === 'N = nodes.filter(n => n.nodeType === 'input'); if (iN.length === 0)input'); if (iN.length === 0) { c.innerHTML = '<p>No input nodes defined { c.innerHTML = '<p>No input nodes defined.</p>'; return; } iN.forEach(n.</p>'; return; } iN.forEach(n => { const d = document.createElement('div'); const => { const d = document.createElement('div'); const l = document.createElement('label'); l.htmlFor l = document.createElement('label'); l.htmlFor = `input-${n.id}`; l.textContent = `${n.id} (${n.fullName || n.id}):`; const i = document.createElement('input'); = `input-${n.id}`; l.textContent = `${n.id} (${n.fullName || n.id}):`; const i = document.createElement('input'); i.type = 'number'; i.id = ` i.type = 'number'; i.id = `input-${n.id}`; i.name = n.id; i.min = "0"; i.max = "1"; i.step = "0.01"; i.value = "0.5"; d.appendChild(l); d.appendChild(i); c.appendChild(d); }); }
function updateNodeProbabilities(probabilities) { if (!cy) return; const useGradient = document.getElementById('gradient-toggle')?.checked ?? true; cy.nodes().forEach(node => {input-${n.id}`; i.name = n.id; i.min = "0"; i.max const nodeId = node.id(); const nodeType = node.data('nodeType'); let probState1 = null; if = "1"; i.step = "0.01"; i.value = "0.5"; d.appendChild(l); d.appendChild(i); c.appendChild(d); }); }
function updateNodeProbabilities(probabilities) { if (!cy) return; const useGradient = document.getElementById('gradient-toggle')?.checked ?? true; cy.nodes().forEach(node => { const nodeId = node.id(); const nodeType = node.data (probabilities && probabilities[nodeId] && probabilities[nodeId]["1"] !== undefined) { probState1 = probabilities[nodeId]["1"]; node.data('currentProbLabel', `P(1)=${probState1('nodeType'); let probState1 = null; if (probabilities && probabilities[nodeId] && probabilities[nodeId]["1"] !== undefined) { probState1 = probabilities[nodeId]["1"]; node.data('current.toFixed(3)}`); } else if (nodeType === 'input') { const inputElement = document.getElementByIdProbLabel', `P(1)=${probState1.toFixed(3)}`); } else if (nodeType === 'input') { const inputElement = document.getElementById(`input-${nodeId}`); const currentVal = inputElement(`input-${nodeId}`); const currentVal = inputElement ? (parseFloat(inputElement.value) || 0 ? (parseFloat(inputElement.value) || 0.5) : 0.5; probState1.5) : 0.5; probState1 = currentVal; node.data('currentProbLabel', `P = currentVal; node.data('currentProbLabel', `P(1)=${probState1.toFixed(3)}`); } else { node.data('currentProbLabel', '(N/A)'); } let baseBgColor = nodeType === '(1)=${probState1.toFixed(3)}`); } else { node.data('currentProbLabel', '(N/A)'); } let baseBgColor = nodeType === 'input' ? '#add8e6'input' ? '#add8e6' : '#f0e68c'; let textColor = '#33 : '#f0e68c'; let textColor = '#333'; let finalBgColor = baseBg3'; let finalBgColor = baseBgColor; if (probState1 !== null) { if (useGradientColor; if (probState1 !== null) { if (useGradient) { finalBgColor = `rgb(${) { finalBgColor = `rgb(${Math.round(255 * (1 - probState1))}, ${MathMath.round(255 * (1 - probState1))}, ${Math.round(255.round(255 * probState1)}, 0)`; textColor = '#333'; } else { * probState1)}, 0)`; textColor = '#333'; } else { finalBgColor = '#4B finalBgColor = '#4B0082'; textColor = '#FFFFFF'; } } else if (!useGradient0082'; textColor = '#FFFFFF'; } } else if (!useGradient && nodeType !== 'input') && nodeType !== 'input') { finalBgColor = '#4B0082'; textColor = '#FFFFFF { finalBgColor = '#4B0082'; textColor = '#FFFFFF'; } node.style({ 'background-color': finalBgColor, 'color': textColor }); }); cy.style().update(); }
function displayLLMReason'; } node.style({ 'background-color': finalBgColor, 'color': textColor }); }); cy.style().updateing(reasoningText) { const d=document.getElementById('llm-reasoning-content'); if((); }
function displayLLMReasoning(reasoningText) { const d=document.getElementById('llm-reasoning-content'); if(d) d.textContent=reasoningText||"N/A";}
d) d.textContent=reasoningText||"N/A";}
function displayLLMContext(context)function displayLLMContext(context) { if(!context)return; const iD=document.getElementById('input { if(!context)return; const iD=document.getElementById('input-context'); const sD=document-context'); const sD=document.getElementById('structure-context'); const dD=document.getElementById('node-descriptions-context'); if(!iD || !sD || !dD) return; let iH='<ul>.getElementById('structure-context'); const dD=document.getElementById('node-descriptions-context'); if(!iD';(context.input_states||[]).forEach(s=>{iH+=`<li>${s.node}( || !sD || !dD) return; let iH='<ul>';(context.input_states||[]).forEach(s=>{iH+=`<li>${s.node}(${s.description}): ${s.state${s.description}): ${s.state} (p=${s.value.toFixed(2)})</li>`;});i} (p=${s.value.toFixed(2)})</li>`;});iH+='</ul>';iD.innerHTML=iH+='</ul>';iD.innerHTML=iH||'N/A'; let sH='<ul>';Object.entriesH||'N/A'; let sH='<ul>';Object.entries(context.node_dependencies||{}(context.node_dependencies||{}).forEach(([n,p])=>{sH+=`<li>${n}: ${p.).forEach(([n,p])=>{sH+=`<li>${n}: ${p.join(',')||'None'}</li>`;join(',')||'None'}</li>`;});sH+='</ul>';sD.innerHTML=sH||'});sH+='</ul>';sD.innerHTML=sH||'N/A'; let dH='N/A'; let dH='<ul>';Object.entries(context.node_descriptions||{}).forEach(([<ul>';Object.entries(context.node_descriptions||{}).forEach(([n,d])=>{dH+=`<li>${n}: ${d}</li>`;});dH+='</ul>';dD.innerHTML=dH||'N/A';n,d])=>{dH+=`<li>${n}: ${d}</li>`;});dH+='</ul>';dD.innerHTML}
function setStatusMessage(elementId, message, type) { const el=document.getElementById(elementId=dH||'N/A';}
function setStatusMessage(elementId, message, type) { const el=document.getElementById(elementId); if(el){el.textContent=message; el.className=`status-message ${); if(el){el.textContent=message; el.className=`status-message ${type||''}`;}}
asynctype||''}`;}}
async function retryFetch(fetchFn, maxRetries, onRetry) { let last function retryFetch(fetchFn, maxRetries, onRetry) { let lastError; for(let attempt=Error; for(let attempt=1; attempt<=maxRetries; attempt++){ try{ await fetchFn(); return1; attempt<=maxRetries; attempt++){ try{ await fetchFn(); return; }catch(error){ last; }catch(error){ lastError=error; console.warn(`Attempt ${attempt} fail: ${error.message}`);Error=error; console.warn(`Attempt ${attempt} fail: ${error.message}`); if(attempt<maxRetries){ if(attempt<maxRetries){ if(onRetry)onRetry(); await new Promise(resolve=>setTimeout(resolve, if(onRetry)onRetry(); await new Promise(resolve=>setTimeout(resolve, 1000*attempt)); 1000*attempt));}}} throw lastError; }
function logPrediction(inputs, probabilities) { const}}} throw lastError; }
function logPrediction(inputs, probabilities) { const logEntry = { timestamp: new Date logEntry = { timestamp: new Date().toISOString(), configId: currentConfig ? currentConfig.id : "unknown().toISOString(), configId: currentConfig ? currentConfig.id : "unknown", configName: currentConfig ? current", configName: currentConfig ? currentConfig.name : "Unknown", inputs: { ...inputs }, probabilities: {}Config.name : "Unknown", inputs: { ...inputs }, probabilities: {} }; for (const n in probabilities) }; for (const n in probabilities) { logEntry.probabilities[n] = probabilities[n]["1"]; } { logEntry.probabilities[n] = probabilities[n]["1"]; } for (const i in inputs) { for (const i in inputs) { if (!(i in logEntry.probabilities)) { logEntry.probabilities[i if (!(i in logEntry.probabilities)) { logEntry.probabilities[i] = inputs[i]; } }] = inputs[i]; } } sessionLog.push(logEntry); const logCountEl = document.getElementById(' sessionLog.push(logEntry); const logCountEl = document.getElementById('log-count'); if (logCountlog-count'); if (logCountEl) logCountEl.textContent = `Session logs: ${sessionLog.El) logCountEl.textContent = `Session logs: ${sessionLog.length}`; }
function clearSessionLoglength}`; }
function clearSessionLog() { sessionLog = []; const logCountEl = document.getElementById('log() { sessionLog = []; const logCountEl = document.getElementById('log-count'); if (logCountEl-count'); if (logCountEl) logCountEl.textContent = `Session logs: 0`; }
) logCountEl.textContent = `Session logs: 0`; }
function clearLLMOutputs() { constfunction clearLLMOutputs() { const reasonEl=document.getElementById('llm-reasoning-content'); if( reasonEl=document.getElementById('llm-reasoning-content'); if(reasonEl) reasonEl.textContent='Run prediction...'; const ic=document.getElementById('input-context'); if(ic) ic.innerHTML='<p>NreasonEl) reasonEl.textContent='Run prediction...'; const ic=document.getElementById('input-context'); if(ic) ic.innerHTML='<p>N/A</p>'; const sc=document.getElementById('structure-context/A</p>'; const sc=document.getElementById('structure-context'); if(sc) sc.innerHTML='<p>'); if(sc) sc.innerHTML='<p>N/A</p>'; const dc=document.getElementByIdN/A</p>'; const dc=document.getElementById('node-descriptions-context'); if(dc) dc('node-descriptions-context'); if(dc) dc.innerHTML='<p>N/A</p>';.innerHTML='<p>N/A</p>'; setStatusMessage('predict-status', "", ""); }
 setStatusMessage('predict-status', "", ""); }
function downloadSessionLog() { if(sessionLog.length===0){function downloadSessionLog() { if(sessionLog.length===0){alert("No logs.");return;} const h=['Timestamp','alert("No logs.");return;} const h=['Timestamp','ConfigID','ConfigName','NodeID','ProbP1ConfigID','ConfigName','NodeID','ProbP1']; const r=[]; sessionLog.forEach(l=>{ const probs']; const r=[]; sessionLog.forEach(l=>{ const probs = l.probabilities || {}; Object.entries(probs = l.probabilities || {}; Object.entries(probs).forEach(([n,p])=>{ if(typeof p === 'number).forEach(([n,p])=>{ if(typeof p === 'number') r.push([l.timestamp,l.config') r.push([l.timestamp,l.configId,l.configName,n,p.toFixedId,l.configName,n,p.toFixed(4)]); else console.warn("Skip non-numeric prob(4)]); else console.warn("Skip non-numeric prob:", n); }); }); const csv=Papa.un:", n); }); }); const csv=Papa.unparse({fields:h,data:r}); triggerCsvDownload(csvparse({fields:h,data:r}); triggerCsvDownload(csv, `session_log_${(currentConfig?.name||, `session_log_${(currentConfig?.name||'unsaved').replace(/[^a-z0-'unsaved').replace(/[^a-z0-9]/gi,'_')}`); }
async function downloadAllLogs9]/gi,'_')}`); }
async function downloadAllLogs() { if(!currentConfig||!currentConfig.() { if(!currentConfig||!currentConfig.id||currentConfig.id==="unknown"||currentConfig.id==="defaultid||currentConfig.id==="unknown"||currentConfig.id==="default-config-001"){alert-config-001"){alert("Load saved config.");return;} setStatusMessage('predict-status',"Downloading("Load saved config.");return;} setStatusMessage('predict-status',"Downloading logs...","loading"); showSpinner(true); enableUI(false); await retryFetch(async()=>{ const r = await fetch(`/api/download_log logs...","loading"); showSpinner(true); enableUI(false); await retryFetch(async()=>{ const r =/${currentConfig.id}`); if(!r.ok){ if(r.status === 404) throw new Error await fetch(`/api/download_log/${currentConfig.id}`); if(!r.ok){ if(r.status === 404) throw new Error(`No logs for '${currentConfig.name}'.`); const e = await r(`No logs for '${currentConfig.name}'.`); const e = await r.json().catch(()=>({detail:`HTTP ${r.status}`})); throw new Error(e.detail); } const b = await r.blob(); triggerCsv.json().catch(()=>({detail:`HTTP ${r.status}`})); throw new Error(e.detail); } const b = await r.blob(); triggerCsvDownload(b, `all_logs_${currentConfig.name.replaceDownload(b, `all_logs_${currentConfig.name.replace(/[^a-z0-9]/gi,'_')}`); setStatusMessage('predict-status',"Logs downloaded.","success"); },3,()=>setStatusMessage('predict(/[^a-z0-9]/gi,'_')}`); setStatusMessage('predict-status',"Logs downloaded.-status',"Download fail. Retry...","error")).catch(e=>{setStatusMessage('predict-status',`Log","success"); },3,()=>setStatusMessage('predict-status',"Download fail. Retry...","error")).catch(e=>{ download fail: ${e.message}`,"error");}).finally(()=>{enableUI(true);showSpinner(false);setStatusMessage('predict-status',`Log download fail: ${e.message}`,"error");}).finally(()=>{enableUI(true});}
function triggerCsvDownload(csvDataOrBlob, baseFilename) { const blob = (csvDataOrBlob instanceof Blob) ? csvDataOrBlob : new Blob([csvDataOrBlob], { type: 'text/);showSpinner(false);});}
function triggerCsvDownload(csvDataOrBlob, baseFilename) { const blob = (csvDataOrBlob instanceof Blob) ? csvDataOrBlob : new Blob([csvDataOrBlob], { type:csv;charset=utf-8;' }); const link = document.createElement("a"); const url = URL.createObjectURL(blob 'text/csv;charset=utf-8;' }); const link = document.createElement("a"); const url = URL.createObjectURL(blob); link.setAttribute("href", url); const timestampStr = new Date().toISOString().replace(/[:.]); link.setAttribute("href", url); const timestampStr = new Date().toISOString().replace(/[:.]/g, '-'); link.setAttribute("download", `${baseFilename}_${timestampStr}.csv`); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL/g, '-'); link.setAttribute("download", `${baseFilename}_${timestampStr}.csv`); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); }
function markConfigUnsaved() { const d = document.getElementById('current(url); }
function markConfigUnsaved() { const d = document.getElementById('current-config-name'); if (d && !d.textContent.endsWith('*')) { d.textContent += '*'; setStatusMessage('-config-name'); if (d && !d.textContent.endsWith('*')) { d.textContent += '*'; setStatusMessage('config-status', "Graph modified. Save changes.", "loading"); } }
function clearUnconfig-status', "Graph modified. Save changes.", "loading"); } }
function clearUnsavedMark() { const d = document.getElementById('current-config-name'); if (d && d.textContent.endsWith('*'))savedMark() { const d = document.getElementById('current-config-name'); if (d && d.textContent { d.textContent = d.textContent.slice(0, -1); } }
function updateEditorPlaceholderText() { const.endsWith('*')) { d.textContent = d.textContent.slice(0, -1); } }
function updateEditorPlaceholder p=document.querySelector('.graph-editor p'); if(!p)return; let m=""; const menusOk=contextMenuText() { const p=document.querySelector('.graph-editor p'); if(!p)return; let m="";Instance!==null; const edgesOk=edgeHandlesInstance!==null; if(!menusOk&&!edgesOk) m const menusOk=contextMenuInstance!==null; const edgesOk=edgeHandlesInstance!==null; if(!menusOk&&!="Editing unavailable: Failed libraries."; else if(!menusOk) m="Right-click menus disabled. Drag node handles toedgesOk) m="Editing unavailable: Failed libraries."; else if(!menusOk) m="Right-click menus disabled. Drag add edges."; else if(!edgesOk) m="Edge drawing disabled. Use right-click menus to edit."; else node handles to add edges."; else if(!edgesOk) m="Edge drawing disabled. Use right-click menus to edit."; else m="Right-click nodes/canvas to edit. Drag node handles for edges."; p.textContent=m; p m="Right-click nodes/canvas to edit. Drag handles for edges."; p.textContent=m; p..style.color=(menusOk&&edgesOk)?'#555':'orange'; }

// --- Editing Functionsstyle.color=(menusOk&&edgesOk)?'#555':'orange'; }

// --- Editing Functions ---
function addNodeFromMenu(nodeType, position) { if (!cy) return; newNodeCounter++; const ---
function addNodeFromMenu(nodeType, position) { if (!cy) return; newNodeCounter++; const idBase = nodeType === 'input' ? 'Input' : 'Hidden'; let id = `${idBase}_ idBase = nodeType === 'input' ? 'Input' : 'Hidden'; let id = `${idBase}_${newNodeCounter}`; while (cy.getElementById(id).length > 0) { newNodeCounter++; id = `${idBase}_${newNodeCounter}`; while (cy.getElementById(id).length > 0) { newNodeCounter++; id = `${${newNodeCounter}`; } const name = prompt(`Enter display name for new ${nodeType} node (ID: ${idBase}_${newNodeCounter}`; } const name = prompt(`Enter display name for new ${nodeType} node (id}):`, id); if (name === null) return; const newNodeData = { group: 'nodes', data: { idID: ${id}):`, id); if (name === null) return; const newNodeData = { group: 'nodes', data: { id: id.trim(), fullName: name.trim() || id.trim(), nodeType: node: id.trim(), fullName: name.trim() || id.trim(), nodeType: nodeType }, position: position }; cy.add(newNodeData); console.log(`Added ${nodeType} node: ID=${id},Type }, position: position }; cy.add(newNodeData); console.log(`Added ${nodeType} node: Name=${newNodeData.data.fullName}`); if (nodeType === 'input') { updateInputControls(cy. ID=${id}, Name=${newNodeData.data.fullName}`); if (nodeType === 'input') { updateInputnodes().map(n => n.data())); } updateNodeProbabilities({}); runLayout(); markConfigUnsaved();Controls(cy.nodes().map(n => n.data())); } updateNodeProbabilities({}); runLayout(); mark }
function deleteElement(target) { if (!cy || !target || (!target.isNode && !target.isEdgeConfigUnsaved(); }
function deleteElement(target) { if (!cy || !target || (!target.isNode)) return; const id = target.id(); const type = target.isNode() ? 'node' : 'edge'; && !target.isEdge)) return; const id = target.id(); const type = target.isNode() ? 'node' : 'edge'; let name = target.data('fullName') || id; if (target. let name = target.data('fullName') || id; if (target.isEdge()){ name = `${target.isEdge()){ name = `${target.source().id()}->${target.target().id()}`; } if (source().id()}->${target.target().id()}`; } if (confirm(`Delete ${type} "${name}"?`)) { const wasInputNode = target.isNode() && target.data('nodeType') === 'input';confirm(`Delete ${type} "${name}"?`)) { const wasInputNode = target.isNode() && target.data cy.remove(target); console.log(`Removed ${type}: ${id}`); if(wasInputNode){ updateInputControls(('nodeType') === 'input'; cy.remove(target); console.log(`Removed ${type}: ${id}`); if(wasInputNode){ updateInputControls(cy.nodes().map(n => n.data())); } markConfigcy.nodes().map(n => n.data())); } markConfigUnsaved(); } }
function convertNodeType(targetUnsaved(); } }
function convertNodeType(targetNode) { if (!cy || !targetNode || !targetNode.Node) { if (!cy || !targetNode || !targetNode.isNode()) return; const currentType = targetNode.data('nodeType'); const newType = currentType === 'input' ? 'hidden' : 'input';isNode()) return; const currentType = targetNode.data('nodeType'); const newType = currentType === 'input' const nodeId = targetNode.id(); if (confirm(`Convert node "${targetNode.data('fullName') || nodeId}" from ? 'hidden' : 'input'; const nodeId = targetNode.id(); if (confirm(`Convert node "${targetNode.data('fullName') || nodeId}" from ${currentType} to ${newType}?`)) { targetNode.data ${currentType} to ${newType}?`)) { targetNode.data('nodeType', newType); console('nodeType', newType); console.log(`Converted node ${nodeId} to ${newType}`); cy.style().update.log(`Converted node ${nodeId} to ${newType}`); cy.style().update(); updateInputControls(cy.(); updateInputControls(cy.nodes().map(n => n.data())); updateNodeProbabilities({}); markConfigUnsaved();nodes().map(n => n.data())); updateNodeProbabilities({}); markConfigUnsaved(); } }

// --- Configuration Management Functions ---
async function loadDefaultConfig() { console.log("Fetching default configuration structure..."); try { await retryFetch } }

// --- Configuration Management Functions ---
async function loadDefaultConfig() { console.log("Fetching default configuration structure..."); try(async () => { const r = await fetch('/api/configs/default'); if (!r.ok) throw { await retryFetch(async () => { const r = await fetch('/api/configs/default'); if (!r.ok new Error(`HTTP ${r.status}`); defaultGraphStructure = await r.json(); console.log("Default structure) throw new Error(`HTTP ${r.status}`); defaultGraphStructure = await r.json(); console.log(" stored."); }, 3); } catch (e) { console.error('Error fetching default struct:', e); defaultDefault structure stored."); }, 3); } catch (e) { console.error('Error fetching default struct:', e); defaultGraphStructure = null; throw e; } }
function addDefaultToDropdown() { const s=document.getElementByIdGraphStructure = null; throw e; } }
function addDefaultToDropdown() { const s=document.getElementById('load-config-select'); if(!defaultGraphStructure)return; let e=false; for(let i=('load-config-select'); if(!defaultGraphStructure)return; let e=false; for(let i=0;i<s.options.length;i++){if(s.options[i].value===defaultGraph0;i<s.options.length;i++){if(s.options[i].value===defaultGraphStructure.id){e=true;break;}} if(!e){const o=document.createElement('option');Structure.id){e=true;break;}} if(!e){const o=document.createElement('option');o.value=defaultGraphStructure.id;o.textContent=`${defaultGraphStructure.name} (Default)`;o.value=defaultGraphStructure.id;o.textContent=`${defaultGraphStructure.name} (Default)`; if(s.options.length>0&&s.options[0].value===""){s.insertBefore(o if(s.options.length>0&&s.options[0].value===""){s.insertBefore(o,s.options[1]);}else{s.insertBefore(o,s.firstChild);} console.log("Added Default to dropdown,s.options[1]);}else{s.insertBefore(o,s.firstChild);} console.log("Added Default to dropdown.");} }
function loadGraphData(configData, isDefault=false) { if(!cy||!config.");} }
function loadGraphData(configData, isDefault=false) { if(!cy||!configData||!configData.graph_structure){console.error("Load graph error"); return;} console.log(`LoadingData||!configData.graph_structure){console.error("Load graph error"); return;} console.log(`Loading: ${configData.name}`); const elems = configData.graph_structure.nodes.map(n=>({data: ${configData.name}`); const elems = configData.graph_structure.nodes.map(n=>({data:{id:n.id,fullName:n.fullName,nodeType:n.nodeType}})).concat(:{id:n.id,fullName:n.fullName,nodeType:n.nodeType}})).concat(configData.graph_structure.edges.map(e=>({data:{source:e.source,target:e.targetconfigData.graph_structure.edges.map(e=>({data:{source:e.source,target:e.target}}))); cy.elements().remove(); cy.add(elems); runLayout(); currentConfig={...configData}; document}}))); cy.elements().remove(); cy.add(elems); runLayout(); currentConfig={...configData}; document.getElementById('config-name').value=isDefault?'':currentConfig.name; document.getElementById('current-config-name.getElementById('config-name').value=isDefault?'':currentConfig.name; document.getElementById('current-').textContent=currentConfig.name; updateInputControls(currentConfig.graph_structure.nodes); updateNodeProbconfig-name').textContent=currentConfig.name; updateInputControls(currentConfig.graph_structure.nodes);abilities({}); clearSessionLog(); clearLLMOutputs(); clearUnsavedMark(); selectConfigInDropdown(currentConfig.id); updateNodeProbabilities({}); clearSessionLog(); clearLLMOutputs(); clearUnsavedMark(); selectConfigInDropdown(currentConfig.id); }
async function saveConfiguration() { const ni=document.getElementById('config-name'); const n= }
async function saveConfiguration() { const ni=document.getElementById('config-name'); const n=ni.valueni.value.trim(); if(!n){setStatusMessage('config-status',"Enter name.","error");return;} if.trim(); if(!n){setStatusMessage('config-status',"Enter name.","error");return;} if(!cy(!cy){setStatusMessage('config-status',"Graph not init.","error");return;} setStatusMessage('config){setStatusMessage('config-status',"Graph not init.","error");return;} setStatusMessage('config-status',"Saving...","loading"); showSpinner(true); enableUI(false); const struct = {nodes: cy.-status',"Saving...","loading"); showSpinner(true); enableUI(false); const struct = {nodes:nodes().map(node=>({id:node.id(),fullName:node.data('fullName'),nodeType: cy.nodes().map(node=>({id:node.id(),fullName:node.data('fullName'),nodenode.data('nodeType')})), edges: cy.edges().map(edge=>({source:edge.Type:node.data('nodeType')})), edges: cy.edges().map(edge=>({source:source().id(),target:edge.target().id()}))}; await retryFetch(async()=>{ const r=await fetch('/edge.source().id(),target:edge.target().id()}))}; await retryFetch(async()=>{ const rapi/configs',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify=await fetch('/api/configs',{method:'POST',headers:{'Content-Type':'application/json'},body({config_name:n,graph_structure:struct})}); const d=await r.json(); if(!:JSON.stringify({config_name:n,graph_structure:struct})}); const d=await r.r.ok)throw new Error(d.detail||`HTTP ${r.status}`); currentConfig={id:json(); if(!r.ok)throw new Error(d.detail||`HTTP ${r.status}`); currentConfig={id:d.config_id,name:d.config_name,graph_structure:struct};d.config_id,name:d.config_name,graph_structure:struct}; document.getElementById('current-config-name').textContent=currentConfig.name; ni.value=''; setStatusMessage('config-status',`Saved as '${d.config_name}'.`,"success"); await loadConfigList(); selectConfigInDropdown(d.config_id); clearSessionLog(); clearUnsavedMark();},3,()=>setStatusMessage(' document.getElementById('current-config-name').textContent=currentConfig.name; ni.value=''; setStatusMessage('config-status',`Saved as '${d.config_name}'.`,"success"); await loadConfigList(); selectConfigInDropdown(d.config_id); clearSessionLog(); clearUnsavedMark();},3,()=>setStatusMessage('config-status',"Save fail. Retry...","error")).catch(e=>{console.error('Saveconfig-status',"Save fail. Retry...","error")).catch(e=>{console.error('Save error:',e); setStatusMessage('config-status',`Save fail: ${e.message}`,"error");}).finally(()=>{enable error:',e); setStatusMessage('config-status',`Save fail: ${e.message}`,"error");}).finally(()=>{enableUI(true);showSpinner(false);}); }
async function loadConfigList() { console.log("UI(true);showSpinner(false);}); }
async function loadConfigList() { console.log("Updating saved list..."); try { await retryFetch(async()=>{ const r=await fetch('/api/configs'); if(!r.ok)throw newUpdating saved list..."); try { await retryFetch(async()=>{ const r=await fetch('/api/configs'); if(!r. Error(`HTTP ${r.status}`); const configs=await r.json(); const s=document.getElementById('load-configok)throw new Error(`HTTP ${r.status}`); const configs=await r.json(); const s=document.getElementById('load-config-select'); const curSel=s.value; const optsToRemove=[]; for(let i=-select'); const curSel=s.value; const optsToRemove=[]; for(let i=0;i<0;i<s.options.length;i++){const v=s.options[i].value; ifs.options.length;i++){const v=s.options[i].value; if(v!==""&&v!=="default-config-001"){optsToRemove.push(s.options[i]);}}(v!==""&&v!=="default-config-001"){optsToRemove.push(s.options optsToRemove.forEach(opt=>s.removeChild(opt)); configs.forEach(c=>{const o=document.createElement('[i]);}} optsToRemove.forEach(opt=>s.removeChild(opt)); configs.forEach(c=>{const o=document.createElement('option');o.value=c.id;o.textContent=c.name;soption');o.value=c.id;o.textContent=c.name;s.appendChild(o);.appendChild(o);}); s.value=curSel; let foundCur=false; if(currentConfig){for(let}); s.value=curSel; let foundCur=false; if(currentConfig){for(let i= i=0;i<s.options.length;i++){if(s.options[i].value===0;i<s.options.length;i++){if(s.options[i].value===currentConfigcurrentConfig.id){s.value=currentConfig.id;foundCur=true;break;}}} if(!foundCur&&.id){s.value=currentConfig.id;foundCur=true;break;}}} if(!foundCurdefaultGraphStructure){s.value=defaultGraphStructure.id;} if(s.value==="")s.selectedIndex=0;&&defaultGraphStructure){s.value=defaultGraphStructure.id;} if(s.value==="")s. console.log("Saved list updated.");},3); } catch(e){ console.error('Load list error:',e); setselectedIndex=0; console.log("Saved list updated.");},3); } catch(e){ console.error('Load list errorStatusMessage('config-status',`Failed list load: ${e.message}`,"error");}}
async function:',e); setStatusMessage('config-status',`Failed list load: ${e.message}`,"error");}}
async function loadSelectedConfiguration() { const s=document.getElementById('load-config-select'); const id=s loadSelectedConfiguration() { const s=document.getElementById('load-config-select'); const id=s.value.value; if(!id){setStatusMessage('config-status',"Select config.","error");return;} if(!; if(!id){setStatusMessage('config-status',"Select config.","error");return;} if(!cy){cy){setStatusMessage('config-status',"Graph not ready.","error");return;} setStatusMessage('config-setStatusMessage('config-status',"Graph not ready.","error");return;} setStatusMessage('config-status',`Loading ${s.options[s.selectedIndex].text}...`,"loading"); showSpinner(true); enableUIstatus',`Loading ${s.options[s.selectedIndex].text}...`,"loading"); showSpinner(true); enableUI(false); await retryFetch(async()=>{ if(id==='default-config-001'&&(false); await retryFetch(async()=>{ if(id==='default-config-001'&&defaultGraphStructure){defaultGraphStructure){loadGraphData(defaultGraphStructure,true);setStatusMessage('config-status',"Default loaded.","success");loadGraphData(defaultGraphStructure,true);setStatusMessage('config-status',"Default loaded.","success");return;} const rreturn;} const r=await fetch(`/api/configs/${id}`); if(!r.ok){const e=await r.json=await fetch(`/api/configs/${id}`); if(!r.ok){const e=await r.json().catch(()=>().catch(()=>({detail:`HTTP ${r.status}`}));throw new Error(e.detail||`HTTP({detail:`HTTP ${r.status}`}));throw new Error(e.detail||`HTTP ${r.status}`);} ${r.status}`);} const d=await r.json(); loadGraphData(d,false); setStatus const d=await r.json(); loadGraphData(d,false); setStatusMessage('config-status',Message('config-status',`Config '${d.name}' loaded.`,"success");},3,()=>setStatusMessage('config`Config '${d.name}' loaded.`,"success");},3,()=>setStatusMessage('config-status',"Load fail. Retry...","error")).catch(e=>{console.error('Load select error:',e); setStatus-status',"Load fail. Retry...","error")).catch(e=>{console.error('Load select error:',e); setStatusMessage('config-status',`Load failed: ${e.message}`,"error");}).finally(()=>{Message('config-status',`Load failed: ${e.message}`,"error");}).finally(()=>{enableUI(enableUI(true);showSpinner(false);});}
async function setDefaultConfiguration() { const s=document.true);showSpinner(false);});}
async function setDefaultConfiguration() { const s=document.getElementById('load-getElementById('load-config-select'); const id=s.value; const name=s.options[s.config-select'); const id=s.value; const name=s.options[s.selectedIndex].text;selectedIndex].text; if(!id||id==='default-config-001'){setStatusMessage('config- if(!id||id==='default-config-001'){setStatusMessage('config-status',"Select saved config.","status',"Select saved config.","error");return;} if(!confirm(`Set "${name}" as default?`))error");return;} if(!confirm(`Set "${name}" as default?`))return; setStatusMessage('configreturn; setStatusMessage('config-status',`Setting default...`,"loading"); showSpinner(true); enable-status',`Setting default...`,"loading"); showSpinner(true); enableUI(false); await retryFetchUI(false); await retryFetch(async()=>{ const r=await fetch('/api/configs/set_default',{(async()=>{ const r=await fetch('/api/configs/set_default',{method:'POST',headers:{'method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(id)}); constContent-Type':'application/json'},body:JSON.stringify(id)}); const d=await r.json(); d=await r.json(); if(!r.ok)throw new Error(d.detail||`HTTP ${ if(!r.ok)throw new Error(d.detail||`HTTP ${r.status}`); setStatusMessager.status}`); setStatusMessage('config-status',`Set '${name}' as default.`,"success"); await('config-status',`Set '${name}' as default.`,"success"); await loadDefaultConfig();},3,() loadDefaultConfig();},3,()=>setStatusMessage('config-status',"Set default fail. Retry...","error")).catch(e=>{console.error('Set default error:',e);setStatusMessage('config-status',`Set=>setStatusMessage('config-status',"Set default fail. Retry...","error")).catch(e=>{console.error('Set default failed: ${e.message}`,"error");}).finally(()=>{enableUI(true);showSpinner(false); default error:',e);setStatusMessage('config-status',`Set default failed: ${e.message}`,"error");}).finally(()=>{enableUI(true);showSpinner(false);});}
async function deleteSelectedConfiguration() { const s});}
async function deleteSelectedConfiguration() { const s = document.getElementById('load-config-select'); const id=document.getElementById('load-config-select'); const id=s.value; const name=s.options = s.value; const name = s.options[s.selectedIndex].text; if (!id || id === 'default-config-001') { setStatusMessage('config-status', "Select a saved config to delete.", "[s.selectedIndex].text; if(!id||id==='default-config-001'){setStatusMessage('config-error"); return; } if (!confirm(`Delete "${name}"?`)) return; setStatusMessage('config-status', `status',"Select saved config.","error");return;} if(!confirm(`Delete "${name}"?`))return; setStatusMessage('config-status',`Deleting...`,"loading"); showSpinner(true); enableUI(false);Deleting...`, "loading"); showSpinner(true); enableUI(false); await retryFetch(async () => { await retryFetch(async()=>{ const r=await fetch(`/api/configs/${id}`,{method:'DELETE'}); const const r = await fetch(`/api/configs/${id}`, { method: 'DELETE' }); const d = await r.json d=await r.json(); if(!r.ok)throw new Error(d.detail||`HTTP ${(); if (!r.ok) throw new Error(d.detail || `HTTP ${r.status}`); setStatusMessage('configr.status}`); setStatusMessage('config-status',`Deleted '${name}'.`,"success"); // ** FIX WAS-status', `Deleted '${name}'.`, "success"); // Corrected syntax error below: && currentConfig if (current HERE: Corrected typo: &¤tConfig -> && currentConfig if(currentConfig && currentConfig.id===Config && currentConfig.id === id) { if (defaultGraphStructure) { loadGraphData(defaultGraphStructure, true);id){if(defaultGraphStructure){loadGraphData(defaultGraphStructure,true);setStatusMessage('config-status',`Deleted setStatusMessage('config-status', `Deleted '${name}'. Default loaded.`, "success"); } else { cy.elements().remove(); currentConfig = null; updateInputControls([]); clearSessionLog(); clearLLMOutputs(); document.getElementById '${name}'. Default loaded.`,"success");}else{cy.elements().remove();currentConfig=null;updateInputControls([]);clearSessionLog();clearLLMOutputs();document.getElementById('current-config-name').textContent="None";('current-config-name').textContent = "None"; setStatusMessage('config-status', `Deleted '${namesetStatusMessage('config-status',`Deleted '${name}'. Load another.`,"success");}} await loadConfigList();},3,}'. Load another.`, "success"); } } await loadConfigList(); }, 3, () => setStatusMessage('config-status', "Delete fail. Retry...", "error")) .catch(e => { console.error('Delete error()=>setStatusMessage('config-status',"Delete fail. Retry...","error")).catch(e=>{console.error:', e); setStatusMessage('config-status', `Delete failed: ${e.message}`, "error"); })('Delete error:',e); setStatusMessage('config-status',`Delete failed: ${e.message}`," .finally(() => { enableUI(true); showSpinner(false); }); }

// --- Initialization Sequence ---
error");}).finally(()=>{enableUI(true);showSpinner(false);});}

// --- Prediction ---
async function fetchAndUpdateLLM() { if(!currentConfig||!currentConfig.graph_structure||!currentConfig.graph_structure.nodesdocument.addEventListener('DOMContentLoaded', async () => {
    console.log("DOM Content Loaded. Starting initialization...");
    if (typeof cytoscape !== 'function') { alert("Error: Cytoscape library failed to load."); setStatusMessage.length===0){alert("Load config first.");return;} if(!cy){alert("Graph not ready.");return;} set('config-status', "Error: Core graph library failed.", "error"); showSpinner(false); return; }StatusMessage('predict-status',"Inputs...","loading"); let inputs={input_values:{}}; let invalid=false; current
    if (!document.getElementById('cy')) { alert("Error: Graph container element 'cy' not found.");Config.graph_structure.nodes.filter(n=>n.nodeType==='input').forEach(n=>{ setStatusMessage('config-status', "Error: Graph container missing.", "error"); showSpinner(false); returnconst el=document.getElementById(`input-${n.id}`);const cont=el?.parentElement; let v=0.5; }
    initializeCytoscape();
    if (!cy) { showSpinner(false); return; }; if(el){v=parseFloat(el.value);if(isNaN(v)||v<0||v>1){
    initializeEditingExtensions();
    initializeUI();
    showSpinner(true); setStatusMessage('config-setStatusMessage('predict-status',`Invalid ${n.id}.`,"error");cont?.classList.add('invalid-status', "Loading config data...", "loading");
    try {
        await loadDefaultConfig();
        if (defaultinput');invalid=true;}else{cont?.classList.remove('invalid-input');}} inputs.input_valuesGraphStructure) { loadGraphData(defaultGraphStructure, true); addDefaultToDropdown(); const select = document.getElementById('load[n.id]=isNaN(v)?0.5:Math.max(0,Math.min(1,v));-config-select'); if(!select.value || select.value === "") { selectConfigInDropdown(defaultGraphStructure.id}); if(invalid){setStatusMessage('predict-status',"Fix inputs (0-1).","error");return;} const payload); } }
        else { throw new Error("Default config data unavailable."); }
        await loadConfigList();={...inputs,graph_structure:currentConfig.graph_structure,config_id:currentConfig.id,config_
        const finalStatus = currentConfig ? `Config '${currentConfig.name}' loaded.` : "Ready.";
name:currentConfig.name}; setStatusMessage('predict-status',"Predicting...","loading"); showSpinner(true); enable        if (!document.getElementById('config-status').classList.contains('error')){ setStatusMessage('config-status',UI(false); clearLLMOutputs(); await retryFetch(async()=>{ const r=await fetch('/api/predict finalStatus, "success"); }
    } catch (error) { console.error("Initialization Data Load Error:", error); if_openai_bn_single_call',{method:'POST',headers:{'Content-Type':'application/json'}, (!document.getElementById('config-status').classList.contains('error')) { setStatusMessage('config-status',body:JSON.stringify(payload)}); const d=await r.json(); if(!r.ok)throw new `Initialization failed: ${error.message}`, "error"); } if (!currentConfig) { updateInputControls([]); document.getElementById(' Error(d.detail||`HTTP ${r.status}`); updateNodeProbabilities(d.probabilities); displayLLMReasoncurrent-config-name').textContent = "None"; } }
    finally { showSpinner(false); }
ing(d.llm_reasoning); displayLLMContext(d.llm_context); setStatus});

// --- Cytoscape Core Initialization ---
function initializeCytoscape() {
    console.log("Message('predict-status',"Complete.","success"); logPrediction(inputs.input_values,d.probabilities);},3,Attempting Cytoscape core initialization...");
    try {
        if (typeof nodeLabelFunc !== 'function') { throw()=>setStatusMessage('predict-status',"Predict fail. Retry...","error")).catch(e=>{console.error(" new Error("Internal Error: nodeLabelFunc not defined before Cytoscape init."); }
        cy = cytoscPredict error:",e);setStatusMessage('predict-status',`Predict failed: ${e.message}`,"error");clearape({
            container: document.getElementById('cy'),
            elements: [],
            style: [
                 { selector:LLMOutputs();}).finally(()=>{enableUI(true);showSpinner(false);});}

// --- Initialization Sequence 'node', style: { 'background-color': '#ccc', 'label': nodeLabelFunc, 'width': 120, 'height': 120, 'shape': 'ellipse', 'text-valign': 'center', 'text-halign': 'center', 'font-size': '10px', ' (Now placed after all functions are defined) ---
document.addEventListener('DOMContentLoaded', async () => {
    console.log("DOM Content Loaded. Starting initialization...");

    // Check core library and container first
    if (typeof cytoscapefont-weight': '100', 'text-wrap': 'wrap', 'text-max-width': 110, 'text-outline-color': '#fff', 'text-outline-width': 1 !== 'function') { alert("Error: Cytoscape library failed to load."); setStatusMessage('config-status, 'color': '#333', 'transition-property': 'background-color, color', 'transition-', "Error: Core graph library failed.", "error"); showSpinner(false); return; }
    if (!duration': '0.5s' } },
                 { selector: 'node[nodeType="input"]',document.getElementById('cy')) { alert("Error: Graph container element 'cy' not found."); setStatusMessage(' style: { 'shape': 'rectangle', 'width': 130, 'height': 70 }config-status', "Error: Graph container missing.", "error"); showSpinner(false); return; }

     },
                 { selector: 'node[nodeType="hidden"]', style: { 'shape': 'ellipse'// 1. Initialize Cytoscape Instance
    initializeCytoscape(); // Creates 'cy' instance

     } },
                 { selector: 'edge', style: { 'width': 2, 'line-color':if (!cy) { showSpinner(false); return; } // Stop if core failed (alert shown inside init)

 '#666', 'target-arrow-shape': 'triangle', 'target-arrow-color': '#6    // 2. Initialize Editing Extensions (includes registration check)
    initializeEditingExtensions(); // Tries to register66', 'curve-style': 'bezier' } },
                 { selector: '.edge-source-active', style: and init extensions on 'cy'

    // 3. Initialize UI Button Listeners
    initializeUI();

 { 'border-width': 3, 'border-color': '#00ff00' } },
    // 4. Load Data (Default & Saved)
    showSpinner(true);
    setStatusMessage('                 { selector: '.eh-grabbed', style: { 'border-width': 3, 'border-config-status', "Loading config data...", "loading");
    try {
        await loadDefaultConfig(); //color': '#007bff' } }
             ],
            layout: { name: 'preset' } Fetch default structure
        if (defaultGraphStructure) {
            loadGraphData(defaultGraphStructure, true); // Load default
        });
        console.log("Cytoscape core initialized successfully.");
    } catch(error) { into cy
            addDefaultToDropdown();
            const select = document.getElementById('load-config-select'); console.error("Failed to initialize Cytoscape Core:", error); alert(`Critical Error initializing graph library: ${error.message}\
            if(!select.value || select.value === "") { selectConfigInDropdown(defaultGraphStructure.idn\n(Check console for more details)`); cy = null; }
}


// --- Editing Extensions Initialization & REG); }
        } else { throw new Error("Default config data unavailable."); }

        await loadConfigList(); // Fetch saved configs
        const finalStatus = currentConfig ? `Config '${currentConfig.name}' loaded.` :ISTRATION ---
function initializeEditingExtensions() {
    console.log("Initializing and Registering editing extensions...");
    if (!cy) { console.error("Cannot init extensions: Cytoscape not ready."); return; }

     "Ready.";
        // Set status message correctly based on whether default loaded
        if (!document.getElementById('config-status').// --- Register & Initialize Edge Handles (with delay) ---
    try {
        if (typeof cytoscapeclassList.contains('error')){
             setStatusMessage('config-status', finalStatus, "success");
        }Edgehandles === 'function' && !didRegisterEdgehandles) {
             cytoscape.use( cytosc

    } catch (error) {
        console.error("Initialization Data Load Error:", error);
         // Don'tapeEdgehandles );
             didRegisterEdgehandles = true; console.log("Edgehandles registered.");
             setTimeout overwrite specific error from default load if it happened
         if (!document.getElementById('config-status').classList.contains('error'))(() => {
                 try {
                     if (!cy) { console.log("Edgehandles init deferred: cy became null {
             setStatusMessage('config-status', `Initialization failed: ${error.message}`, "error");
         }
        ."); return };
                     edgeHandlesInstance = cy.edgehandles({
                          snap: true, handleNodes: 'if (!currentConfig) { updateInputControls([]); document.getElementById('current-config-name').textContent = "None"; }
node', handleSize: 10, handleColor: '#007bff', handlePosition: 'middle top', preview:    } finally {
        showSpinner(false);
    }
});


console.log("script.js loaded true, hoverDelay: 150,
                          edgeType: (src, tgt) => 'flat', and execution potentially started (check DOMContentLoaded).");
